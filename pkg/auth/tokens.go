package auth

import (
	"crypto/rsa"
	"errors"
	"fmt"
	"io/ioutil"
	"time"

	jwt "github.com/golang-jwt/jwt/v4"
	"github.com/google/uuid"
	"github.com/segmentio/ksuid"
)

// Time constraints for jwt token issuance
const (
	accessTokenDuration  = 1 * time.Hour
	refreshTokenDuration = 2 * time.Hour
	accessRefreshOverlap = -15 * time.Minute
)

var (
	signingMethod = jwt.SigningMethodRS512
)

// TokenManager handles the creation and verification of RSA signed JWT tokens. To
// facilitate signing key rollover, TokenManager can accept multiple keys identified by
// a time ordered ksuid. JWT tokens generated by token managers include a kid field (key
// id) in the header that allows the token manager to verify the key with the specified
// signature. To sign keys, the TokenManager will always use the latest private key by
// the ksuid ordering.
type TokenManager struct {
	audience         string
	keyID            ksuid.KSUID
	privateKey       *rsa.PrivateKey
	verificationKeys map[ksuid.KSUID]*rsa.PublicKey
}

// Claims is a cosmos-specific claims data structure that can be extended to hold user
// data and authorization claims required for the game.
type Claims struct {
	jwt.RegisteredClaims
}

// New creates a TokenManager with the specified keys and audience. The keys should be
// a map of KSUID strings to paths of files that contain PEM encoded RSA private keys.
// This input is specifically designed for the config environment variable so that keys
// can be loaded from k8s or vault secrets that are mounted as files on disk.
func New(keys map[string]string, audience string) (tm *TokenManager, err error) {
	tm = &TokenManager{
		audience:         audience,
		verificationKeys: make(map[ksuid.KSUID]*rsa.PublicKey),
	}

	for kid, path := range keys {
		var keyID ksuid.KSUID
		if keyID, err = ksuid.Parse(kid); err != nil {
			return nil, fmt.Errorf("could not parse kid %q for path %s: %s", kid, path, err)
		}

		var data []byte
		if data, err = ioutil.ReadFile(path); err != nil {
			return nil, fmt.Errorf("could not read kid %s from %s: %s", kid, path, err)
		}

		var key *rsa.PrivateKey
		if key, err = jwt.ParseRSAPrivateKeyFromPEM(data); err != nil {
			return nil, fmt.Errorf("could not parse RSA private key kid %s from %s: %s", kid, path, err)
		}

		tm.verificationKeys[keyID] = &key.PublicKey

		if tm.privateKey == nil || keyID.Time().After(tm.keyID.Time()) {
			tm.keyID = keyID
			tm.privateKey = key
		}
	}

	return tm, nil
}

// Verify an access or a refresh token after parsing and return its claims.
func (tm *TokenManager) Verify(tks string) (claims *Claims, err error) {
	var token *jwt.Token
	if token, err = jwt.ParseWithClaims(tks, &Claims{}, tm.keyFunc); err != nil {
		return nil, err
	}

	var ok bool
	if claims, ok = token.Claims.(*Claims); ok && token.Valid {
		if !claims.VerifyAudience(tm.audience, true) {
			return nil, fmt.Errorf("invalid audience %q", claims.Audience)
		}
		return claims, nil
	}

	return nil, fmt.Errorf("could not parse or validate claims from %T", token.Claims)
}

// Parse an access or refresh token verifying its signature but do not verify its
// claims. This ensures that valid JWT tokens are still accepted but claims can be
// handled on a case-by-case basis; e.g. validating an expired access token during
// reauthentication.
func (tm *TokenManager) Parse(tks string) (claims *Claims, err error) {
	parser := &jwt.Parser{SkipClaimsValidation: true}
	claims = &Claims{}
	if _, err = parser.ParseWithClaims(tks, claims, tm.keyFunc); err != nil {
		return nil, err
	}
	return claims, nil
}

// Sign a jwt token and return the token string
func (tm *TokenManager) Sign(token *jwt.Token) (tks string, err error) {
	// Sanity check to prevent nil panics
	if tm.privateKey == nil || tm.keyID.IsNil() {
		return "", errors.New("token manager is not initialized with signing keys")
	}

	// Add the kid (key id - part of the JWT standard claims) to the header.
	token.Header["kid"] = tm.keyID.String()
	return token.SignedString(tm.privateKey)
}

// CreateAccessToken for the specified user.
func (tm *TokenManager) CreateAccessToken(email string) (_ *jwt.Token, err error) {
	// Create claims for the access token, using access token defaults.
	now := time.Now()
	claims := &Claims{
		RegisteredClaims: jwt.RegisteredClaims{
			ID:        uuid.NewString(), // ID is randomly generated and shared between access and refresh tokens
			Issuer:    "",
			Audience:  jwt.ClaimStrings{tm.audience},
			Subject:   email,
			IssuedAt:  jwt.NewNumericDate(now),
			NotBefore: jwt.NewNumericDate(now),
			ExpiresAt: jwt.NewNumericDate(now.Add(accessTokenDuration)),
		},
	}

	return jwt.NewWithClaims(signingMethod, claims), nil
}

// CreateRefreshToken from the access token.
func (tm *TokenManager) CreateRefreshToken(accessToken *jwt.Token) (refreshToken *jwt.Token, err error) {
	accessClaims, ok := accessToken.Claims.(*Claims)
	if !ok {
		return nil, errors.New("could not retrieve cosmos claims from access token")
	}

	claims := &Claims{
		RegisteredClaims: jwt.RegisteredClaims{
			ID:        accessClaims.ID, // ID is randomly generated and shared between access and refresh tokens.
			Issuer:    accessClaims.Issuer,
			Audience:  accessClaims.Audience,
			Subject:   accessClaims.Subject,
			IssuedAt:  accessClaims.IssuedAt,
			NotBefore: jwt.NewNumericDate(accessClaims.ExpiresAt.Time.Add(accessRefreshOverlap)),
			ExpiresAt: jwt.NewNumericDate(accessClaims.IssuedAt.Time.Add(refreshTokenDuration)),
		},
	}

	return jwt.NewWithClaims(signingMethod, claims), nil
}

// Keys returns the public keys for testing
func (tm *TokenManager) Keys() map[ksuid.KSUID]*rsa.PublicKey {
	return tm.verificationKeys
}

// CurrentKey returns the ksuid of the current key being used to sign tokens.
func (tm *TokenManager) CurrentKey() ksuid.KSUID {
	return tm.keyID
}

// keyFunc selects the RSA public key from the list of managed internal keys based on
// the kid field in the token header. If the key doesn't exist an error is returned and
// the token will be invalid.
func (tm *TokenManager) keyFunc(token *jwt.Token) (key interface{}, err error) {
	// Per JWT security notice: do not forget to validate alg is expected
	if _, ok := token.Method.(*jwt.SigningMethodRSA); !ok {
		return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
	}

	kid, ok := token.Header["kid"]
	if !ok {
		return nil, errors.New("token does not have kid in header")
	}

	var keyID ksuid.KSUID
	if keyID, err = ksuid.Parse(kid.(string)); err != nil {
		return nil, fmt.Errorf("could not parse kid: %s", err)
	}

	if key, ok = tm.verificationKeys[keyID]; !ok {
		return nil, errors.New("unknown signing key")
	}
	return key, nil
}
